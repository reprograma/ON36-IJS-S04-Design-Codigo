# Princípios de Design de Código

Os princípios de design de código são diretrizes e boas práticas que as desenvolvedoras seguem ao escrever software para garantir que o código seja legível, sustentável, escalável e de fácil manutenção. 

## DRY (Don't Repeat Yourself)

O princípio DRY (Don't Repeat Yourself) é uma filosofia de design de software que promove a eliminação de duplicação de código. Ele sugere que cada parte do sistema deve ter uma única representação autoritativa, e qualquer duplicação deve ser removida. Isso reduz a redundância no código, facilitando sua manutenção e evolução.

Vamos considerar um sistema de gerenciamento de cursos online, onde diferentes cursos têm características específicas, como título, descrição, preço e duração. Cada curso também pode ter diferentes tipos de materiais de aprendizagem, como vídeos, textos e exercícios.

Vamos começar com uma abordagem não DRY, onde cada curso é representado por uma classe separada:

```typescript
class VideoCourse {
    title: string;
    description: string;
    price: number;
    duration: number;
    materials: string[];

    constructor(title: string, description: string, price: number, duration: number, materials: string[]) {
        this.title = title;
        this.description = description;
        this.price = price;
        this.duration = duration;
        this.materials = materials;
    }

    displayInfo(): void {
        console.log(`Course Title: ${this.title}`);
        console.log(`Description: ${this.description}`);
        console.log(`Price: $${this.price}`);
        console.log(`Duration: ${this.duration} hours`);
        console.log(`Materials: ${this.materials.join(', ')}`);
    }
}
```
```typescript

class TextCourse {
    title: string;
    description: string;
    price: number;
    duration: number;
    materials: string[];

    constructor(title: string, description: string, price: number, duration: number, materials: string[]) {
        this.title = title;
        this.description = description;
        this.price = price;
        this.duration = duration;
        this.materials = materials;
    }

    displayInfo(): void {
        console.log(`Course Title: ${this.title}`);
        console.log(`Description: ${this.description}`);
        console.log(`Price: $${this.price}`);
        console.log(`Duration: ${this.duration} hours`);
        console.log(`Materials: ${this.materials.join(', ')}`);
    }
}
```
```typescript
class ExerciseCourse {
    title: string;
    description: string;
    price: number;
    duration: number;
    materials: string[];

    constructor(title: string, description: string, price: number, duration: number, materials: string[]) {
        this.title = title;
        this.description = description;
        this.price = price;
        this.duration = duration;
        this.materials = materials;
    }

    displayInfo(): void {
        console.log(`Course Title: ${this.title}`);
        console.log(`Description: ${this.description}`);
        console.log(`Price: $${this.price}`);
        console.log(`Duration: ${this.duration} hours`);
        console.log(`Materials: ${this.materials.join(', ')}`);
    }
}
```

Neste exemplo, estamos repetindo o código em cada classe de curso. Vamos aplicar o princípio DRY para eliminar essa duplicação. Podemos criar uma classe base genérica `Course` que contém os atributos comuns a todos os cursos e depois estender essa classe para os diferentes tipos de cursos:

```typescript
class Course {
    title: string;
    description: string;
    price: number;
    duration: number;
    materials: string[];

    constructor(title: string, description: string, price: number, duration: number, materials: string[]) {
        this.title = title;
        this.description = description;
        this.price = price;
        this.duration = duration;
        this.materials = materials;
    }

    displayInfo(): void {
        console.log(`Course Title: ${this.title}`);
        console.log(`Description: ${this.description}`);
        console.log(`Price: $${this.price}`);
        console.log(`Duration: ${this.duration} hours`);
        console.log(`Materials: ${this.materials.join(', ')}`);
    }
}
```

```typescript
class VideoCourse extends Course {
    constructor(title: string, description: string, price: number, duration: number, materials: string[]) {
        super(title, description, price, duration, materials);
    }
}
```

```typescript
class TextCourse extends Course {
    constructor(title: string, description: string, price: number, duration: number, materials: string[]) {
        super(title, description, price, duration, materials);
    }
}
```

```typescript
class ExerciseCourse extends Course {
    constructor(title: string, description: string, price: number, duration: number, materials: string[]) {
        super(title, description, price, duration, materials);
    }
}
```

Agora, temos uma única definição de classe `Course` que contém os atributos comuns a todos os tipos de cursos. Isso elimina a duplicação de código e segue o princípio DRY, tornando nosso código mais limpo e fácil de manter. Se precisarmos adicionar novos tipos de cursos no futuro, podemos fazer isso facilmente estendendo a classe `Course`.


## SOLID

O princípio SOLID é um conjunto de cinco princípios de design de software que ajudam a criar sistemas mais robustos, flexíveis e fáceis de manter. Cada letra do acrônimo SOLID representa um princípio específico, que, quando aplicado em conjunto, promove um design de software modular e eficiente. 

Aqui está uma visão geral de cada princípio:

- **S - Single Responsibility Principle (Princípio da Responsabilidade Única)**: Uma classe deve ter apenas uma razão para mudar. Em outras palavras, uma classe deve ter uma única responsabilidade ou propósito. Isso facilita a manutenção e a evolução do software, pois mudanças em uma parte do sistema não afetam outras partes desnecessariamente.

- **O - Open/Closed Principle (Princípio Aberto/Fechado)**: Entidades de software (como classes, módulos, funções, etc.) devem ser abertas para extensão, mas fechadas para modificação. Isso significa que você deve ser capaz de adicionar novos comportamentos ao sistema sem alterar o código existente. Esse princípio ajuda a minimizar o risco de introduzir bugs ao fazer mudanças e facilita a extensão do sistema.

- **L - Liskov Substitution Principle (Princípio da Substituição de Liskov)**: Objetos de uma superclasse devem ser substituíveis por objetos de uma subclasse sem alterar as propriedades desejáveis do programa (correção, tarefa realizada, etc.). Isso assegura que as subclasses sejam substituíveis por suas superclasses sem causar erros ou comportamentos inesperados.

- **I - Interface Segregation Principle (Princípio da Segregação de Interface)**: Muitas interfaces específicas são melhores do que uma interface única e geral. Isso significa que é preferível ter várias interfaces pequenas e especializadas em vez de uma interface grande e complexa. Dessa forma, as classes que implementam essas interfaces são obrigadas a implementar apenas os métodos que realmente utilizam, o que reduz o acoplamento e melhora a coesão.

- **D - Dependency Inversion Principle (Princípio da Inversão de Dependência)**: Dependências devem ser de abstrações e não de concretudes. Em outras palavras, o código de alto nível não deve depender do código de baixo nível, mas ambos devem depender de abstrações. Além disso, abstrações não devem depender de detalhes; detalhes devem depender de abstrações. Esse princípio promove um design mais flexível e desacoplado, facilitando a substituição e o teste de componentes.

## Aplicação dos Princípios SOLID

Aplicar os princípios SOLID ajuda a criar sistemas que são mais fáceis de entender, manter e expandir. Eles incentivam um design modular e desacoplado, facilitando a manutenção e a extensão do software sem introduzir erros ou complexidade desnecessária. Ao seguir esses princípios, você pode melhorar a qualidade do código e criar sistemas mais resilientes e adaptáveis às mudanças.



```lua
+---------------------+
|    donation-app     |
+---------------------+
          |
          |
          v
+---------------------+
|         src         |
+---------------------+
          |
   +------+-------+
   |              |
   v              v
+---+---+    +----+----+    +----+----+    +----+----+
|controllers|    |  models |    |  routes |    |  utils  |
+---+---+    +----+----+    +----+----+    +----+----+
    |             |              |              |
    |             |              |              |
+---+---+    +----+----+    +----+----+    +----+----+
| Donation|    |  State  |    |   City   |    |Neighborhood|
+---+---+    +----+----+    +----+----+    +----+----+
          .        .              .              .
          .        .              .              .
          |        |              |              |
     +----+--+ +----+--+      +----+--+      +----+--+
     |   DonationController  |  StateController  |  ...  |
     +----+--+ +----+--+      +----+--+      +----+--+
          .        .              .              .
          .        .              .              .
          |        |              |              |
     +----+--+ +----+--+      +----+--+      +----+--+
     | donationRoutes.ts    |  stateRoutes.ts  |  ...  |
     +----+--+ +----+--+      +----+--+      +----+--+
               .                             .
               .                             .
               |                             |
         +-----+------+              +-----+------+
         | database.json |              |   server.ts  |
         +--------------+              +--------------+

```

Vamos criar uma aplicação de gerenciamento de doações de alimentos para pessoas, seguindo o padrão de arquitetura MVC (Model-View-Controller) e aplicando os princípios SOLID (Single Responsibility Principle, Open/Closed Principle, Liskov Substitution Principle, Interface Segregation Principle, Dependency Inversion Principle).


**Passo 1:** Estrutura do Projeto
```
donation-app/
├── src/
│   ├── controllers/
│   │   ├── DonationController.ts
│   │   ├── StateController.ts
│   │   ├── CityController.ts
│   │   └── NeighborhoodController.ts
│   ├── models/
│   │   ├── Donation.ts
│   │   ├── State.ts
│   │   ├── City.ts
│   │   └── Neighborhood.ts
│   ├── routes/
│   │   ├── donationRoutes.ts
│   │   ├── stateRoutes.ts
│   │   ├── cityRoutes.ts
│   │   └── neighborhoodRoutes.ts
│   ├── utils/
│   │   └── database.json
│   └── server.ts
├── package.json
└── tsconfig.json
```

**Passo 2:** Implementação

**Model (M)**:
```typescript
// src/models/State.ts
export interface State {
  id: string;
  name: string;
}

// src/models/City.ts
export interface City {
  id: string;
  name: string;
  stateId: string;
}

// src/models/Neighborhood.ts
export interface Neighborhood {
  id: string;
  name: string;
  cityId: string;
}
```

**Controller (C)**:
```typescript
// src/controllers/StateController.ts
import { State } from '../models/State';
import { DataStorage } from '../utils/DataStorage';

export class StateController {
  private dataStorage: DataStorage<State>;

  constructor(dataStorage: DataStorage<State>) {
    this.dataStorage = dataStorage;
  }

  public getAllStates(): State[] {
    return this.dataStorage.getAll();
  }

  public getStateById(id: string): State | undefined {
    return this.dataStorage.getById(id);
  }

  public createState(name: string): State {
    const newState: State = {
      id: Math.random().toString(36).substr(2, 9),
      name
    };
    this.dataStorage.add(newState);
    return newState;
  }
}

// src/controllers/CityController.ts
import { City } from '../models/City';
import { DataStorage } from '../utils/DataStorage';

export class CityController {
  private dataStorage: DataStorage<City>;

  constructor(dataStorage: DataStorage<City>) {
    this.dataStorage = dataStorage;
  }

  public getAllCities(): City[] {
    return this.dataStorage.getAll();
  }

  public getCitiesByState(stateId: string): City[] {
    return this.dataStorage.getAll().filter(city => city.stateId === stateId);
  }

  public createCity(name: string, stateId: string): City {
    const newCity: City = {
      id: Math.random().toString(36).substr(2, 9),
      name,
      stateId
    };
    this.dataStorage.add(newCity);
    return newCity;
  }
}

// src/controllers/NeighborhoodController.ts
import { Neighborhood } from '../models/Neighborhood';
import { DataStorage } from '../utils/DataStorage';

export class NeighborhoodController {
  private dataStorage: DataStorage<Neighborhood>;

  constructor(dataStorage: DataStorage<Neighborhood>) {
    this.dataStorage = dataStorage;
  }

  public getAllNeighborhoods(): Neighborhood[] {
    return this.dataStorage.getAll();
  }

  public getNeighborhoodsByCity(cityId: string): Neighborhood[] {
    return this.dataStorage.getAll().filter(neighborhood => neighborhood.cityId === cityId);
  }

  public createNeighborhood(name: string, cityId: string): Neighborhood {
    const newNeighborhood: Neighborhood = {
      id: Math.random().toString(36).substr(2, 9),
      name,
      cityId
    };
    this.dataStorage.add(newNeighborhood);
    return newNeighborhood;
  }
}
```

**Router (R)**:
```typescript
// src/routes/stateRoutes.ts
import express, { Request, Response } from 'express';
import { StateController } from '../controllers/StateController';
import { DataStorage } from '../utils/DataStorage';
import { State } from '../models/State';

const router = express.Router();
const dataStorage = new DataStorage<State>(); // Implementação específica do armazenamento de dados para estados
const stateController = new StateController(dataStorage);

router.get('/states', (req: Request, res: Response) => {
  const states = stateController.getAllStates();
  res.json(states);
});

router.get('/states/:id', (req: Request, res: Response) => {
  const { id } = req.params;
  const state = stateController.getStateById(id);
  if (!state) {
    return res.status(404).json({ error: 'State not found' });
  }
  res.json(state);
});

router.post('/states', (req: Request, res: Response) => {
  const { name } = req.body;
  if (!name) {
    return res.status(400).json({ error: 'State name is required' });
  }
  const newState = stateController.createState(name);
  res.status(201).json(newState);
});

export default router;
```

**Server (S)**:
```typescript
// src/server.ts
import express from 'express';
import bodyParser from 'body-parser';
import stateRoutes from './routes/stateRoutes';
import cityRoutes from './routes/cityRoutes';
import neighborhoodRoutes from './routes/neighborhoodRoutes';

const app = express();
const PORT = process.env.PORT || 3000;

app.use(bodyParser.json());
app.use('/api', stateRoutes);
app.use('/api', cityRoutes);
app.use('/api', neighborhoodRoutes);

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

**Single Responsibility Principle (S)**:
- Cada classe no diretório `controllers` tem uma responsabilidade única: `StateController`, `CityController` e `NeighborhoodController` gerenciam operações relacionadas a estados, cidades e bairros, respectivamente. Além disso, a classe `JsonDataStorage` no diretório `utils` tem a responsabilidade única de carregar e salvar dados em formato JSON.

**Open/Closed Principle (O)**:
- As classes e funções estão abertas para extensão, pois novos tipos de operações podem ser adicionados facilmente através da criação de novos controladores (por exemplo, `CountyController`, `StreetController`) sem a necessidade de modificar as classes existentes. Além disso, as rotas estão abertas para extensão, pois novos endpoints podem ser adicionados facilmente sem modificar os existentes.

**Liskov Substitution Principle (L)**:
- Embora não haja herança direta neste exemplo, se houver subtipos de `State`, `City` ou `Neighborhood`, eles devem ser substituíveis por objetos do tipo `State`, `City`

 ou `Neighborhood`, respectivamente, sem afetar o comportamento do programa. Isso significa que podemos introduzir novos tipos de estados, cidades ou bairros sem modificar o código existente.

**Interface Segregation Principle (I)**:
- Embora não haja interfaces explícitas neste exemplo, a estrutura do código é projetada para garantir que as classes consumam apenas o que precisam. Por exemplo, a classe `StateController` não depende de funcionalidades relacionadas a cidades ou bairros, e vice-versa.

**Dependency Inversion Principle (D)**:
- Os controladores (`StateController`, `CityController`, `NeighborhoodController`) não dependem diretamente das implementações concretas de armazenamento de dados (por exemplo, JSON, banco de dados SQL). Em vez disso, eles dependem de uma abstração (`DataStorage`) para carregar e salvar dados, promovendo uma arquitetura mais flexível e desacoplada.