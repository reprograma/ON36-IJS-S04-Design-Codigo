# Princípios de Design de Código

Os princípios de design de código são diretrizes e boas práticas que as desenvolvedoras seguem ao escrever software para garantir que o código seja legível, sustentável, escalável e de fácil manutenção. 

## As práticas Mais Comuns de Design de Código

### DRY (Don't Repeat Yourself)

O princípio DRY (Don't Repeat Yourself) é uma filosofia de design de software que promove a eliminação de duplicação de código. Ele sugere que cada parte do sistema deve ter uma única representação autoritativa, e qualquer duplicação deve ser removida. Isso reduz a redundância no código, facilitando sua manutenção e evolução.

### KISS (Keep It Simple, Stupid)

O princípio KISS (Keep It Simple, Stupid) enfatiza a importância de manter o código simples e direto, evitando complexidade desnecessária. A ideia é que sistemas simples são mais fáceis de entender, manter e escalar.

### YAGNI (You Aren't Gonna Need It)

O princípio YAGNI (You Aren't Gonna Need It) é um dos princípios do Extreme Programming (XP) e afirma que você não deve adicionar funcionalidades que não são necessárias no momento. Ele encoraja a implementação de funcionalidades apenas quando há uma necessidade real, evitando o excesso de complexidade e desperdício de recursos.

### Documentação

Documentar o código de forma clara e concisa, fornecendo informações sobre o propósito, funcionamento e uso de classes, métodos e variáveis.

### SOLID

O princípio SOLID é um conjunto de cinco princípios de design de software que ajudam a criar sistemas mais robustos, flexíveis e fáceis de manter. Cada letra do acrônimo SOLID representa um princípio específico, que, quando aplicado em conjunto, promove um design de software modular e eficiente. 

Aqui está uma visão geral de cada princípio:

- **S - Single Responsibility Principle (Princípio da Responsabilidade Única)**: Uma classe deve ter apenas uma razão para mudar. Em outras palavras, uma classe deve ter uma única responsabilidade ou propósito. Isso facilita a manutenção e a evolução do software, pois mudanças em uma parte do sistema não afetam outras partes desnecessariamente.

- **O - Open/Closed Principle (Princípio Aberto/Fechado)**: Entidades de software (como classes, módulos, funções, etc.) devem ser abertas para extensão, mas fechadas para modificação. Isso significa que você deve ser capaz de adicionar novos comportamentos ao sistema sem alterar o código existente. Esse princípio ajuda a minimizar o risco de introduzir bugs ao fazer mudanças e facilita a extensão do sistema.

- **L - Liskov Substitution Principle (Princípio da Substituição de Liskov)**: Objetos de uma superclasse devem ser substituíveis por objetos de uma subclasse sem alterar as propriedades desejáveis do programa (correção, tarefa realizada, etc.). Isso assegura que as subclasses sejam substituíveis por suas superclasses sem causar erros ou comportamentos inesperados.

- **I - Interface Segregation Principle (Princípio da Segregação de Interface)**: Muitas interfaces específicas são melhores do que uma interface única e geral. Isso significa que é preferível ter várias interfaces pequenas e especializadas em vez de uma interface grande e complexa. Dessa forma, as classes que implementam essas interfaces são obrigadas a implementar apenas os métodos que realmente utilizam, o que reduz o acoplamento e melhora a coesão.

- **D - Dependency Inversion Principle (Princípio da Inversão de Dependência)**: Dependências devem ser de abstrações e não de concretudes. Em outras palavras, o código de alto nível não deve depender do código de baixo nível, mas ambos devem depender de abstrações. Além disso, abstrações não devem depender de detalhes; detalhes devem depender de abstrações. Esse princípio promove um design mais flexível e desacoplado, facilitando a substituição e o teste de componentes.
